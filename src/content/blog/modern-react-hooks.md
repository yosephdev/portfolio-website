
---
title: "Understanding Modern React Hooks"
date: "2023-05-12T12:00:00Z"
readingTime: "8 min read"
author: "Yoseph Berhane"
tags: ["React", "JavaScript", "Hooks"]
excerpt: "A deep dive into React's latest hooks and how they can improve your components."
content: "# Understanding Modern React Hooks\n\nReact Hooks have revolutionized how we write React components, moving away from class components and toward a more functional approach. In this article, we'll explore some of the more advanced hooks and patterns.\n\n## useState vs useReducer\n\nWhile **useState** is perfect for simple state values, **useReducer** shines when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.\n\n```jsx\n// Using useState\nconst [count, setCount] = useState(0);\n\n// Equivalent using useReducer\nconst [count, dispatch] = useReducer((state, action) => {\n  switch (action.type) {\n    case 'increment':\n      return state + 1;\n    case 'decrement':\n      return state - 1;\n    default:\n      return state;\n  }\n}, 0);\n```\n\n## useCallback for Performance\n\nThe **useCallback** hook returns a memoized version of the callback that only changes if one of the dependencies has changed.\n\n```jsx\nconst memoizedCallback = useCallback(\n  () => {\n    doSomething(a, b);\n  },\n  [a, b],\n);\n```\n\n## useMemo for Expensive Calculations\n\n**useMemo** is similar to useCallback but is designed to memoize computed values rather than functions.\n\n```jsx\nconst memoizedValue = useMemo(() => {\n  return computeExpensiveValue(a, b);\n}, [a, b]);\n```\n\n## Custom Hooks for Reusability\n\nOne of the most powerful features of hooks is the ability to create your own for reusable logic.\n\n```jsx\nfunction useWindowSize() {\n  const [size, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n  \n  useEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  return size;\n}\n\n// Usage\nfunction MyComponent() {\n  const size = useWindowSize();\n  return (\n    <div>\n      Width: {size.width}, Height: {size.height}\n    </div>\n  );\n}\n```\n\n## Conclusion\n\nHooks provide a more direct API to React concepts you were already familiar with: props, state, context, refs, and lifecycle. They also offer a powerful new way to combine them."
relatedPosts: ["typescript-tips", "state-management"]
---
