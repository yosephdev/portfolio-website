
---
title: "10 TypeScript Tips for Better Code"
date: "2023-04-23T10:30:00Z"
readingTime: "6 min read"
author: "Yoseph Berhane"
tags: ["TypeScript", "Best Practices"]
excerpt: "Practical TypeScript tips that will help you write more maintainable code."
content: "# 10 TypeScript Tips for Better Code\n\nTypeScript continues to grow in popularity, and for good reason. Here are some tips to help you write better TypeScript code.\n\n## 1. Use Type Inference Where Possible\n\nTypeScript's type inference is powerful. Don't add type annotations when they're unnecessary.\n\n```typescript\n// Unnecessarily verbose\nconst name: string = \"TypeScript\";\n\n// Let TypeScript infer the type\nconst name = \"TypeScript\";\n```\n\n## 2. Understand the 'any' Type\n\nThe `any` type effectively opts out of type checking. Use it sparingly and consider `unknown` as a safer alternative.\n\n## 3. Leverage Union Types\n\nUnion types are powerful for representing values that could be one of several types.\n\n```typescript\ntype StringOrNumber = string | number;\n\nfunction process(input: StringOrNumber) {\n  if (typeof input === \"string\") {\n    return input.toUpperCase();\n  }\n  return input * 2;\n}\n```\n\n## 4. Use Intersection Types for Object Combinations\n\nIntersection types combine multiple types into one.\n\n```typescript\ntype Person = {\n  name: string;\n};\n\ntype Employee = {\n  id: number;\n  department: string;\n};\n\ntype EmployeeRecord = Person & Employee;\n```\n\n## 5. Implement Discriminated Unions\n\nThese are useful for modeling state transitions or API responses.\n\n```typescript\ntype LoadingState = {\n  status: \"loading\";\n};\n\ntype SuccessState = {\n  status: \"success\";\n  data: any;\n};\n\ntype ErrorState = {\n  status: \"error\";\n  error: Error;\n};\n\ntype State = LoadingState | SuccessState | ErrorState;\n```\n\n## 6. Make Good Use of 'readonly'\n\nThe `readonly` modifier prevents properties from being changed after initialization.\n\n```typescript\ninterface Config {\n  readonly apiUrl: string;\n}\n```\n\n## 7. Use Type Guards\n\nType guards help narrow down the type of a value.\n\n```typescript\nfunction isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n```\n\n## 8. Leverage Generics for Reusable Code\n\nGenerics allow you to create reusable components.\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n```\n\n## 9. Use Mapped Types for Transformations\n\nMapped types allow you to create new types from existing ones.\n\n```typescript\ntype Nullable<T> = {\n  [P in keyof T]: T[P] | null;\n};\n```\n\n## 10. Optimize for Strictness\n\nEnable strict mode in your tsconfig.json to catch more errors.\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true\n  }\n}\n```"
relatedPosts: ["modern-react-hooks", "nextjs-vs-remix"]
---
